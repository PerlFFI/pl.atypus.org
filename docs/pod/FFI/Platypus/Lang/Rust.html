<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>FFI::Platypus::Lang::Rust</title>
    <script type="text/javascript" src="https://shjs.wdlabs.com/sh_main.min.js"></script>
    <script type="text/javascript" src="https://shjs.wdlabs.com/lang/sh_perl.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://shjs.wdlabs.com/css/sh_acid.css">
    <link type="text/css" rel="stylesheet" href="https://hatch.wdlabs.com/css/default.css">
  </head>
  <body onload="sh_highlightDocument();">
    <div class="nx-header-flag-1"></div>
    <div class="nx-header-flag-2"></div>
    <div class="nx-header-title"><a href="/">ðŸŒ»</a> <a href="/pod/">ðŸ“–</a> <a href="/pod/FFI.html">FFI</a>::<a href="/pod/FFI/Platypus.html">Platypus</a>::<a href="/pod/FFI/Platypus/Lang.html">Lang</a>::Rust</div>
    <!--FFI::Platypus::Lang::Rust--><a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Passing_and_Returning_Integers'>Passing and Returning Integers</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#String_Arguments'>String Arguments</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Returning_allocated_strings'>Returning allocated strings</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Returning_allocated_strings%2C_but_keeping_ownership'>Returning allocated strings, but keeping ownership</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Return_static_strings'>Return static strings</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Callbacks'>Callbacks</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Slice_arguments'>Slice arguments</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Tuples'>Tuples</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Objects'>Objects</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Panic!'>Panic!</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Rust_Source'>Rust Source</a>
      <li class='indexItem indexItem3'><a href='#Perl_Source'>Perl Source</a>
      <li class='indexItem indexItem3'><a href='#Execute'>Execute</a>
      <li class='indexItem indexItem3'><a href='#Notes'>Notes</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#native_type_map'>native_type_map</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>FFI::Platypus::Lang::Rust - Documentation and tools for using Platypus with the Rust programming language</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.11</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>Rust:</p>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 #[no_mangle]
 pub extern &#34;C&#34; fn add(a: i32, b: i32) -&#62; i32 {
     a + b
 }</pre>

<p>Perl:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;add&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( add =&#62; [&#39;i32&#39;, &#39;i32&#39;] =&#62; &#39;i32&#39; );
 
 print add(1,2), &#34;\n&#34;;  # prints 3</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides native Rust types for <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> in order to reduce cognitive load and concentrate on Rust and forget about C types. This document also documents issues and caveats that I have discovered in my attempts to work with Rust and FFI.</p>

<p>This module is somewhat experimental. It is also available for adoption for anyone either sufficiently knowledgeable about Rust or eager enough to learn enough about Rust. If you are interested, please send me a pull request or two on the project&#39;s GitHub.</p>

<p>Note that in addition to using pre-compiled Rust libraries, you can bundle Rust code with your Perl distribution using <a href="/pod/FFI/Build.html" class="podlinkpod"
>FFI::Build</a> and <a href="/pod/FFI/Build/File/Cargo.html" class="podlinkpod"
>FFI::Build::File::Cargo</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<p>The examples in this discussion are bundled with this distribution and can be found in the <code>examples</code> directory.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Passing_and_Returning_Integers"
>Passing and Returning Integers</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 #[no_mangle]
 pub extern &#34;C&#34; fn add(a: i32, b: i32) -&#62; i32 {
     a + b
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;add&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( add =&#62; [&#39;i32&#39;, &#39;i32&#39;] =&#62; &#39;i32&#39; );
 
 print add(1,2), &#34;\n&#34;;  # prints 3</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc add.rs
 $ perl add.pl
 3</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Basic types like integers and floating points are the easiest to pass across the FFI boundary. The Platypus Rust language plugin (this module) provides the basic types used by Rust (for example: <code>bool</code>, <code>i32</code>, <code>u64</code>, <code>f64</code>, <code>isize</code> and others) will all work as a Rust programmer would expect. This is nice because you don&#39;t have to think about what the equivalent types would be in C when you are writing your Perl extension in Rust.</p>

<p>Rust symbols are &#34;mangled&#34; by default, which means that you cannot use the name of the function from the source code without knowing what the mangled name is. Rust provides a function attribute <code>#[no_mangle]</code> which will tell the compiler not to mangle the name, making lookup of the symbol possible from other programming languages like Perl.</p>

<p>Rust functions do not use the same ABI as C by default, so if you want to be able to call Rust functions from Perl they need to be declared as <code>extern &#34;C&#34;</code> as in this example.</p>

<p>We also set the &#34;crate type&#34; to <code>cdylib</code> in the first line to tell the Rust compiler to generate a dynamic library that will be consumed by a non-Rust language like Perl.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="String_Arguments"
>String Arguments</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::ffi::CStr;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn how_many_characters(s: *const i8) -&#62; isize {
     if s.is_null() {
         return -1;
     }
 
     let s = unsafe { CStr::from_ptr(s) };
 
     match s.to_str() {
         Ok(s) =&#62; s.chars().count() as isize,
         Err(_) =&#62; -2,
     }
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;argument&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( how_many_characters =&#62; [&#39;string&#39;] =&#62; &#39;isize&#39; );
 
 print how_many_characters(undef), &#34;\n&#34;;           # prints -1
 print how_many_characters(&#34;frooble bits&#34;), &#34;\n&#34;;  # prints 12</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc argument.rs
 $ perl argument.pl
 -1
 12</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Strings are considerably more complicated for a number of reasons, but for passing them into Rust code the main challenge is that the representation is different from what C uses. C Uses NULL terminated strings and Rust uses a pointer and size combination that allows NULLs inside strings. Perls internal representation of strings is actually closer to what Rust uses, but when Perl talks to other languages it typically uses C Strings.</p>

<p>Getting a Rust string slice <code>&#38;str</code> requires a few stems</p>

<dl>
<dt><a name="We_have_to_ensure_the_C_pointer_is_not_NULL"
>We have to ensure the C pointer is not <code>NULL</code></a></dt>

<dd>
<p>We return <code>-1</code> to indicate an error here. As we can see from the calling Perl code passing an <code>undef</code> from Perl is equivalent to passing in <code>NULL</code> from C.</p>

<dt><a name="Wrap_using_Cstr"
>Wrap using <code>Cstr</code></a></dt>

<dd>
<p>We then wrap the pointer using an <code>unsafe</code> block. Even though we know at this point that the pointer cannot be <code>NULL</code> it could technically be pointing to uninitialized or unaddressable memory. This <code>unsafe</code> block is unfortunately necessary, though it is relatively isolated so it is easy to reason about and review.</p>

<dt><a name="Convert_to_UTF-8"
>Convert to UTF-8</a></dt>

<dd>
<p>If the string that we passed in is valid UTF-8 we can convert it to a <code>&#38;str</code> using <code>to_str</code> and compute the length of the string. Otherwise, we return -2 error.</p>
</dd>
</dl>

<p>(This example is based on one provided in the <a href="http://jakegoulding.com/rust-ffi-omnibus/string_arguments/" class="podlinkurl"
>Rust FFI Omnibus</a>)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Returning_allocated_strings"
>Returning allocated strings</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::ffi::CString;
 use std::iter;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn theme_song_generate(length: u8) -&#62; *mut i8 {
     let mut song = String::from(&#34;&#128163; &#34;);
     song.extend(iter::repeat(&#34;na &#34;).take(length as usize));
     song.push_str(&#34;Batman! &#128163;&#34;);
 
     let c_str_song = CString::new(song).unwrap();
     c_str_song.into_raw()
 }
 
 #[no_mangle]
 pub extern &#34;C&#34; fn theme_song_free(s: *mut i8) {
     if s.is_null() {
         return;
     }
     unsafe { CString::from_raw(s) };
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;return&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( theme_song_free     =&#62; [&#39;opaque&#39;] =&#62; &#39;void&#39;   );
 
 $ffi-&#62;attach( theme_song_generate =&#62; [&#39;u8&#39;]     =&#62; &#39;opaque&#39; =&#62; sub {
     my($xsub, $length) = @_;
     my $ptr = $xsub-&#62;($length);
     my $str = $ffi-&#62;cast( &#39;opaque&#39; =&#62; &#39;string&#39;, $ptr );
     theme_song_free($ptr);
     $str;
 });
 
 print theme_song_generate(42), &#34;\n&#34;;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc return.rs
 $ perl return.pl
 &#128163; na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na na Batman! &#128163;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>The big challenge of returning strings from Rust into Perl is handling the ownership. In this example we have a C API implemented in Rust that returns a C NULL terminated string, but we have to pass it back into Rust in order to deallocate it when we are done.</p>

<p>Unfortunately Platypus&#39; <code>string</code> type assumes that the callee retains ownership of the returned string, so we have to get the pointer instead as an <code>opaque</code> so that we can later free it. Before freeing it though we cast it into a Perl string.</p>

<p>In order to hide the complexities from caller of our <code>theme_song_generate</code> function, we use a function wrapper to do all of that for us.</p>

<p>(This example is based on one provided in the <a href="http://jakegoulding.com/rust-ffi-omnibus/string_return/" class="podlinkurl"
>Rust FFI Omnibus</a>)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Returning_allocated_strings,_but_keeping_ownership"
>Returning allocated strings, but keeping ownership</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::cell::RefCell;
 use std::ffi::CString;
 use std::iter;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn theme_song_generate(length: u8) -&#62; *const i8 {
     thread_local! {
         static KEEP: RefCell&#60;Option&#60;CString&#62;&#62; = RefCell::new(None);
     }
 
     let mut song = String::from(&#34;&#128163; &#34;);
     song.extend(iter::repeat(&#34;na &#34;).take(length as usize));
     song.push_str(&#34;Batman! &#128163;&#34;);
 
     let c_str_song = CString::new(song).unwrap();
 
     let ptr = c_str_song.as_ptr();
 
     KEEP.with(|k| {
         *k.borrow_mut() = Some(c_str_song);
     });
 
     ptr
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;keep&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( theme_song_generate =&#62; [&#39;u8&#39;] =&#62; &#39;string&#39; );
 
 print theme_song_generate($_), &#34;\n&#34; for 1..10;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc keep.rs
 $ perl keep.pl
 &#128163; na Batman! &#128163;
 &#128163; na na Batman! &#128163;
 &#128163; na na na Batman! &#128163;
 &#128163; na na na na Batman! &#128163;
 &#128163; na na na na na Batman! &#128163;
 &#128163; na na na na na na Batman! &#128163;
 &#128163; na na na na na na na Batman! &#128163;
 &#128163; na na na na na na na na Batman! &#128163;
 &#128163; na na na na na na na na na Batman! &#128163;
 &#128163; na na na na na na na na na na Batman! &#128163;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>For frequently called functions with smaller strings it may make more sense to keep ownership of the string and just return a pointer. Perl makes its own copy on return anyway when you use the <code>string</code> type.</p>

<p>In this example we use thread local storage to keep the <code>CString</code> until the next call when it will be freed. Since we are using thread local storage, it should even be safe to use this interface from a threaded Perl program (although you should probably not be using threaded Perl).</p>

<p>(This example is based on one provided in the <a href="http://jakegoulding.com/rust-ffi-omnibus/string_arguments/" class="podlinkurl"
>Rust FFI Omnibus</a>)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Return_static_strings"
>Return static strings</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 #[no_mangle]
 pub extern &#34;C&#34; fn hello_rust() -&#62; *const u8 {
     &#34;Hello, world!\0&#34;.as_ptr()
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 #[no_mangle]
 pub extern &#34;C&#34; fn hello_rust() -&#62; *const u8 {
     &#34;Hello, world!\0&#34;.as_ptr()
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc static.rs
 $ perl static.pl
 Hello, world!</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Sometimes you just want to return a static NULL terminated string from Rust to Perl. This can sometimes be useful for returning error messages.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Callbacks"
>Callbacks</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::ffi::CString;
 
 type PerlLog = extern &#34;C&#34; fn(line: *const i8);
 
 #[no_mangle]
 pub extern &#34;C&#34; fn rust_log(logf: PerlLog) {
     let lines: [&#38;str; 3] = [&#34;Hello from rust!&#34;, &#34;Something else.&#34;, &#34;The last log line&#34;];
 
     for line in lines.iter() {
         // convert string slice to a C style NULL terminated string
         let line = CString::new(*line).unwrap();
         logf(line.as_ptr());
     }
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;callback&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;type( &#39;(string)-&#62;void&#39; =&#62; &#39;PerlLog&#39; );
 $ffi-&#62;attach( rust_log =&#62; [&#39;PerlLog&#39;] );
 
 my $perl_log = $ffi-&#62;closure(sub {
     my $message = shift;
     print &#34;log&#62; $message\n&#34;;
 });
 
 rust_log($perl_log);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc callback.rs
 $ perl callback.pl
 log&#62; Hello from rust!
 log&#62; Something else.
 log&#62; The last log line</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Calling back into Perl from Rust is easy, so long as you have the correct types defined. The above Rust function takes a C function pointer. We can crate a Platypus closure object from Perl from a plain Perl sub and pass the closure into Rust.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Slice_arguments"
>Slice arguments</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::slice;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn sum_of_even(numbers: *const u32, len: usize) -&#62; i64 {
     if numbers.is_null() {
         return -1;
     }
 
     let numbers = unsafe { slice::from_raw_parts(numbers, len) };
 
     let sum: u32 = numbers.iter().filter(|&#38;v| v % 2 == 0).sum();
     sum as i64
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::slice;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn sum_of_even(numbers: *const u32, len: usize) -&#62; i64 {
     if numbers.is_null() {
         return -1;
     }
 
     let numbers = unsafe { slice::from_raw_parts(numbers, len) };
 
     let sum: u32 = numbers.iter().filter(|&#38;v| v % 2 == 0).sum();
     sum as i64
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc slice.rs
 $ perl slice.pl
 -1
 12</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>A Rust slice is a pointer to a chunk of homogeneous data, and the number of elements in the slice. We can pass these two pieces in from Perl and combine them into a slice in Rust.</p>

<p>This example sums the even numbers from a slice and returns the result.</p>

<p>(This example is based on one provided in the <a href="http://jakegoulding.com/rust-ffi-omnibus/slice_arguments/" class="podlinkurl"
>Rust FFI Omnibus</a>)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Tuples"
>Tuples</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::convert::From;
 
 // A Rust function that accepts a tuple
 fn flip_things_around_rust(tup: (u32, u32)) -&#62; (u32, u32) {
     let (a, b) = tup;
     (b + 1, a - 1)
 }
 
 // A struct that can be passed between C and Rust
 #[repr(C)]
 pub struct Tuple {
     x: u32,
     y: u32,
 }
 
 // Conversion functions
 impl From&#60;(u32, u32)&#62; for Tuple {
     fn from(tup: (u32, u32)) -&#62; Tuple {
         Tuple { x: tup.0, y: tup.1 }
     }
 }
 
 impl From&#60;Tuple&#62; for (u32, u32) {
     fn from(tup: Tuple) -&#62; (u32, u32) {
         (tup.x, tup.y)
     }
 }
 
 // The exported C method
 #[no_mangle]
 pub extern &#34;C&#34; fn flip_things_around(tup: Tuple) -&#62; Tuple {
     flip_things_around_rust(tup.into()).into()
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;tuple&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 package Tuple;
 
 use FFI::Platypus::Record;
 
 use overload
   &#39;&#34;&#34;&#39; =&#62; sub { shift-&#62;as_string },
   bool =&#62; sub { 1 }, fallback =&#62; 1;
 
 record_layout_1($ffi, qw(
   u32 x
   u32 y
 ));
 
 sub as_string {
   my $self = shift;
   sprintf &#34;[%d,%d]&#34;, $self-&#62;x, $self-&#62;y;
 }
 
 package main;
 
 $ffi-&#62;type(&#39;record(Tuple)&#39; =&#62; &#39;tuple_t&#39;);
 $ffi-&#62;attach( flip_things_around =&#62; [&#39;tuple_t&#39;] =&#62; &#39;tuple_t&#39; );
 
 print flip_things_around(Tuple-&#62;new(x =&#62; 10, y =&#62; 20)), &#34;\n&#34;;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ rustc tuple.rs
 $ perl tuple.pl
 [21,9]</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Rust&#39;s tuples do not have a standard representation that can be used directly from Perl, but if your tuple contains only simple types you can use the <a href="/pod/FFI/Platypus/Record.html" class="podlinkpod"
>Platypus Record class</a> and translate in Rust between the tuple and the <code>struct</code>.</p>

<p>Because we are passing in and out the entire <code>struct</code>, not pointers to a <code>struct</code> we don&#39;t have to worry about freeing them from Perl. They just get allocated and freed on the stack.</p>

<p>(This example is based on one provided in the <a href="http://jakegoulding.com/rust-ffi-omnibus/tuples/" class="podlinkurl"
>Rust FFI Omnibus</a>)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Objects"
>Objects</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> use std::cell::RefCell;
 use std::ffi::c_void;
 use std::ffi::CStr;
 use std::ffi::CString;
 
 struct Person {
     name: String,
     lucky_number: i32,
 }
 
 impl Person {
     fn new(name: &#38;str, lucky_number: i32) -&#62; Person {
         Person {
             name: String::from(name),
             lucky_number: lucky_number,
         }
     }
 
     fn get_name(&#38;self) -&#62; String {
         String::from(&#38;self.name)
     }
 
     fn set_name(&#38;mut self, new: &#38;str) {
         self.name = new.to_string();
     }
 
     fn get_lucky_number(&#38;self) -&#62; i32 {
         self.lucky_number
     }
 }
 
 type CPerson = c_void;
 
 #[no_mangle]
 pub extern &#34;C&#34; fn person_new(
     _class: *const i8,
     name: *const i8,
     lucky_number: i32,
 ) -&#62; *mut CPerson {
     let name = unsafe { CStr::from_ptr(name) };
     let name = name.to_string_lossy().into_owned();
     Box::into_raw(Box::new(Person::new(&#38;name, lucky_number))) as *mut CPerson
 }
 
 #[no_mangle]
 pub extern &#34;C&#34; fn person_name(p: *mut CPerson) -&#62; *const i8 {
     thread_local!(
         static KEEP: RefCell&#60;Option&#60;CString&#62;&#62; = RefCell::new(None);
     );
 
     let p = unsafe { &#38;*(p as *mut Person) };
     let name = CString::new(p.get_name()).unwrap();
     let ptr = name.as_ptr();
     KEEP.with(|k| {
         *k.borrow_mut() = Some(name);
     });
     ptr
 }
 
 #[no_mangle]
 pub extern &#34;C&#34; fn person_rename(p: *mut CPerson, new: *const i8) {
     let new = unsafe { CStr::from_ptr(new) };
     let p = unsafe { &#38;mut *(p as *mut Person) };
     if let Ok(new) = new.to_str() {
         p.set_name(new);
     }
 }
 
 #[no_mangle]
 pub extern &#34;C&#34; fn person_lucky_number(p: *mut CPerson) -&#62; i32 {
     let p = unsafe { &#38;*(p as *mut Person) };
     p.get_lucky_number()
 }
 
 #[allow(non_snake_case)]
 #[no_mangle]
 pub extern &#34;C&#34; fn person_DESTROY(p: *mut CPerson) {
     unsafe { Box::from_raw(p as *mut Person) };
 }
 
 #[cfg(test)]
 mod test;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<p>Main class:</p>

<pre class="sh_perl"> package Person;
 
 use strict;
 use warnings;
 use FFI::Platypus 2.00;
 
 our $VERSION = &#39;2.00&#39;;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 
 # use the bundled code as a library
 $ffi-&#62;bundle;
 
 # use the person_ prefix
 $ffi-&#62;mangler(sub {
     my $symbol = shift;
     return &#34;person_$symbol&#34;;
 });
 
 # Create a custom type mapping for the person_t (C) and Person (perl)
 # classes.
 $ffi-&#62;type( &#39;object(Person)&#39; =&#62; &#39;person_t&#39; );
 
 $ffi-&#62;attach( new          =&#62; [ &#39;string&#39;, &#39;string&#39;, &#39;i32&#39; ] =&#62; &#39;person_t&#39; );
 $ffi-&#62;attach( name         =&#62; [ &#39;person_t&#39; ] =&#62; &#39;string&#39; );
 $ffi-&#62;attach( rename       =&#62; [ &#39;person_t&#39;, &#39;string&#39; ] );
 $ffi-&#62;attach( lucky_number =&#62; [ &#39;person_t&#39; ] =&#62; &#39;i32&#39; );
 $ffi-&#62;attach( DESTROY      =&#62; [ &#39;person_t&#39; ] );
 
 1;</pre>

<p>Test:</p>

<pre class="sh_perl"> use Test2::V0;
 use Person;
 
 my $plicease = Person-&#62;new(&#34;Graham Ollis&#34;, 42);
 
 is $plicease-&#62;name, &#34;Graham Ollis&#34;;
 is $plicease-&#62;lucky_number, 42;
 
 $plicease-&#62;rename(&#34;Graham THE Ollis&#34;);
 
 is $plicease-&#62;name, &#34;Graham THE Ollis&#34;;
 
 done_testing;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ prove -lvm t/basic.t
 t/basic.t ..
 # Seeded srand with seed &#39;20221023&#39; from local date.
 ok 1
 ok 2
 ok 3
 1..3
 ok
 All tests successful.
 Files=1, Tests=3,  0 wallclock secs ( 0.02 usr  0.00 sys +  0.19 cusr  0.05 csys =  0.26 CPU)
 Result: PASS</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>This example includes excerpts from a full <code>Person</code> dist which you can find in the <code>examples/Person</code> directory of this distribution. You can install it like a normal Perl distribution using <a href="https://metacpan.org/pod/ExtUtils%3A%3AMakeMaker" class="podlinkpod"
>ExtUtils::MakeMaker</a>, or you can simply run the test file by using <a href="https://metacpan.org/pod/App%3A%3AProve" class="podlinkpod"
>App::Prove</a>. That is because we are using <a href="/pod/FFI/Build.html" class="podlinkpod"
>FFI::Build</a> and <a href="/pod/FFI/Build/File/Cargo.html" class="podlinkpod"
>FFI::Build::File::Cargo</a> to build the Rust parts for us, which know how to work in either mode. There are some stuff that we don&#39;t show you here for brevity: the <code>Makefile.PL</code> for example, and also the rust tests in <code>ffi/src/test.rs</code> which test the Rust crate by calling both its Rust and C interface.</p>

<p>What we have done here is created a Rust <code>struct</code> and then written C wrappers to create, query and modify the object. We&#39;ve also created a destructor to free the object when we are done with it.</p>

<p>In terms of naming conventions, we use <code>person_</code> prefix to denote that these are methods for the Person class that we are creating. This is a common convention in C, where the only namespaces are adding prefixes like this. We also break the convention of using snake case for the destructor <code>person_DESTROY</code> because that will make it easier to bind to from Perl.</p>

<p>When we creat the object we use <code>Box::new</code> and <code>Box::into_raw</code> to create the object on the heap, and to return the opaque pointer back to Perl.</p>

<p>For methods we can convert the raw pointers back into a Person <code>struct</code> using <code>&#38;*(p as *mut Person)</code> inside an <code>unsafe</code> block. In the case of <code>person_rename</code> we need a mutable version so we use <code>&#38;mut *(p as *mut Person)</code> instead.</p>

<p>Finally when we are done with the object we can free it by simply calling <code>Box::from_raw</code>. When it falls out of scope it will be freed.</p>

<p>On the Perl side, we use the <code>mangler</code> method to prepend all symbols with the <code>person_</code> prefix, so that we can attach with just the method name.</p>

<p>We also create a Platypus type for <code>object(Person)</code> and give it the alias <code>person_t</code>. Now we can use it as an argument and return type. This is really a pointer to an opaque (to perl) <code>struct</code>.</p>

<p>If you look at just the test, then you can&#39;t even tell that the implementation for our Person class is in Rust, which is good because your users shouldn&#39;t have to care!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Panic!"
>Panic!</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Rust_Source"
>Rust Source</a></h3>

<pre class="sh_perl"> #![crate_type = &#34;cdylib&#34;]
 
 use std::panic::catch_unwind;
 
 fn might_panic(i: u32) -&#62; u32 {
     if i % 2 == 1 {
         panic!(&#34;oops!&#34;);
     }
     i / 2
 }
 
 #[no_mangle]
 pub extern &#34;C&#34; fn oopsie(i: u32) -&#62; i64 {
     let result = catch_unwind(|| might_panic(i));
     match result {
         Ok(i) =&#62; i as i64,
         Err(_) =&#62; -1,
     }
 }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Source"
>Perl Source</a></h3>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 use FFI::CheckLib qw( find_lib_or_die );
 use File::Basename qw( dirname );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2, lang =&#62; &#39;Rust&#39; );
 $ffi-&#62;lib(
     find_lib_or_die(
         lib        =&#62; &#39;panic&#39;,
         libpath    =&#62; [dirname __FILE__],
         systempath =&#62; [],
     )
 );
 
 $ffi-&#62;attach( oopsie =&#62; [&#39;u32&#39;] =&#62; &#39;i64&#39; );
 
 print oopsie(5), &#34;\n&#34;;   # -1
 print oopsie(10), &#34;\n&#34;;  # 5</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Execute"
>Execute</a></h3>

<pre class="sh_perl"> $ perl panic.pl                     
 thread &#39;&#60;unnamed&#62;&#39; panicked at &#39;oops!&#39;, panic.rs:7:9
 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
 -1
 5</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h3>

<p>Be cautious about code that might <code>panic!</code>. A <code>panic!</code> across the FFI boundary is undefined behavior and usually results in a crash. You will want to catch the panic with a <code>catch_unwind</code> and map to an appropriate error result. In this example, we have a function that returns the integer passed in divided by 2. It does not like odd numbers though and will panic. So we catch the panic and return -1 to indicate an error. As you can see from the run we also get a rather ugly diagnostic, but at least our program didn&#39;t crash!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>Generally you will not use this class directly, instead interacting with the <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> instance. However, the public methods used by Platypus are documented here.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="native_type_map"
>native_type_map</a></h2>

<pre class="sh_perl"> my $hashref = FFI::Platypus::Lang::Rust-&#62;native_type_map;</pre>

<p>This returns a hash reference containing the native aliases for the Rust programming languages. That is the keys are native Rust types and the values are libffi native types.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<dl>
<dt><a name="The_bool_type"
>The <code>bool</code> type</a></dt>

<dd>
<p>As of this writing, the <code>bool</code> type is in practice always a signed 8 bit integer, but this has not been guaranteed by the Rust specification. This module assumes that it is a <code>sint8</code> type, but if that ever changes this module will need to be updated.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<dl>
<dt><a name="FFI::Platypus"
><a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a></a></dt>

<dd>
<p>The Core Platypus documentation.</p>

<dt><a name="FFI::Build::File::Cargo"
><a href="/pod/FFI/Build/File/Cargo.html" class="podlinkpod"
>FFI::Build::File::Cargo</a></a></dt>

<dd>
<p>Bundle Rust code with your FFI / Perl extension.</p>

<dt><a name="The_Rust_FFI_Omnibus"
><a href="http://jakegoulding.com/rust-ffi-omnibus/" class="podlinkurl"
>The Rust FFI Omnibus</a></a></dt>

<dd>
<p>Includes a number of examples of calling Rust from other languages.</p>

<dt><a name="The_Rustonomicon_-_Foreign_Function_Interface"
><a href="https://doc.rust-lang.org/nomicon/ffi.html" class="podlinkurl"
>The Rustonomicon - Foreign Function Interface</a></a></dt>

<dd>
<p>Detailed Rust documentation on crossing the FFI barrier.</p>

<dt><a name="The_Rust_Programming_Language_-_Unsafe_Rust"
><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html" class="podlinkurl"
>The Rust Programming Language - Unsafe Rust</a></a></dt>

<dd>
<p>Unsafe Rust in the Rust Programming Language book.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Author: Graham Ollis &#60;plicease@cpan.org&#62;</p>

<p>Contributors:</p>

<p>Andrew Grangaard (SPAZM)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2015-2022 by Graham Ollis.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>


    <div class="nx-footer">
      <p>
        [
            <a href="https://wdlabs.com">wdlabs.com</a> |
            <a href="https://alienfile.org">alienfile.org</a> |
            <a href="https://pl.atypus.org">pl.atypus.org</a> |
            <a href="https://perlwasm.github.io">perlwasm</a> |
            <a href="https://uperl.github.io">uperl</a>
        ]
        Copyright &copy; 2022 Graham Ollis
      </p>
    </div>
  </body>
</html>
