<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>FFI::Platypus::Type</title>
    <script type="text/javascript" src="https://shjs.wdlabs.com/sh_main.min.js"></script>
    <script type="text/javascript" src="https://shjs.wdlabs.com/lang/sh_perl.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://shjs.wdlabs.com/css/sh_acid.css">
    <link type="text/css" rel="stylesheet" href="https://hatch.wdlabs.com/css/default.css">
  </head>
  <body onload="sh_highlightDocument();">
    <div class="nx-header-flag-1"></div>
    <div class="nx-header-flag-2"></div>
    <div class="nx-header-title"><a href="/">ðŸŒ»</a> <a href="/pod/">ðŸ“–</a> <a href="/pod/FFI.html">FFI</a>::<a href="/pod/FFI/Platypus.html">Platypus</a>::Type</div>
    <!--FFI::Platypus::Type--><a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#meta_information_about_types'>meta information about types</a>
    <li class='indexItem indexItem2'><a href='#converting_types'>converting types</a>
    <li class='indexItem indexItem2'><a href='#aliases'>aliases</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TYPE_CATEGORIES'>TYPE CATEGORIES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Native_types'>Native types</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#the_void_type'>the void type</a>
      <li class='indexItem indexItem3'><a href='#integer_types'>integer types</a>
      <li class='indexItem indexItem3'><a href='#Enum_types'>Enum types</a>
      <li class='indexItem indexItem3'><a href='#Boolean_types'>Boolean types</a>
      <li class='indexItem indexItem3'><a href='#floating_point_types'>floating point types</a>
      <li class='indexItem indexItem3'><a href='#opaque_pointers'>opaque pointers</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Objects'>Objects</a>
    <li class='indexItem indexItem2'><a href='#Strings'>Strings</a>
    <li class='indexItem indexItem2'><a href='#Pointers_and_Arrays_of_Strings'>Pointers and Arrays of Strings</a>
    <li class='indexItem indexItem2'><a href='#Pointer_%2F_References'>Pointer / References</a>
    <li class='indexItem indexItem2'><a href='#Records'>Records</a>
    <li class='indexItem indexItem2'><a href='#Fixed_length_arrays'>Fixed length arrays</a>
    <li class='indexItem indexItem2'><a href='#Variable_length_arrays'>Variable length arrays</a>
    <li class='indexItem indexItem2'><a href='#Closures'>Closures</a>
    <li class='indexItem indexItem2'><a href='#Custom_Types'>Custom Types</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Custom_Types_in_Perl'>Custom Types in Perl</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Example_1%3A_Integer_constants'>Example 1: Integer constants</a>
        <li class='indexItem indexItem4'><a href='#Example_2%3A_Blessed_references'>Example 2: Blessed references</a>
        <li class='indexItem indexItem4'><a href='#Example_3%3A_Pointers_with_pack_%2F_unpack'>Example 3: Pointers with pack / unpack</a>
        <li class='indexItem indexItem4'><a href='#Example_4%3A_Custom_Type_modules_and_the_Custom_Type_API'>Example 4: Custom Type modules and the Custom Type API</a>
        <li class='indexItem indexItem4'><a href='#Example_5%3A_Custom_Type_on_CPAN'>Example 5: Custom Type on CPAN</a>
      </ul>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>FFI::Platypus::Type - Defining types for FFI::Platypus</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 2.03</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>OO Interface:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;type(&#39;int&#39; =&#62; &#39;my_int&#39;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><b>Note</b>: This document assumes that you are using <code>api =&#62; 1</code>, which you should be using for all new code.</p>

<p>This document describes how to define types using <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a>. Types may be &#34;defined&#34; ahead of time, or simply used when defining or attaching functions.</p>

<pre class="sh_perl"> # Example of defining types
 use FFI::Platypus 2.00;
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;type(&#39;int&#39;);
 $ffi-&#62;type(&#39;string&#39;);
 
 # Example of simply using types in function declaration or attachment
 my $f = $ffi-&#62;function(puts =&#62; [&#39;string&#39;] =&#62; &#39;int&#39;);
 $ffi-&#62;attach(puts =&#62; [&#39;string&#39;] =&#62; &#39;int&#39;);</pre>

<p>Unless you are using aliases the <a href="https://metacpan.org/pod/FFI%3A%3APlatypus%23type" class="podlinkpod"
>FFI::Platypus#type</a> method is not necessary, but they will throw an exception if the type is incorrectly specified or not supported, which may be helpful for determining if the types are available or not.</p>

<p>Note: This document sometimes uses the term &#34;C Function&#34; as short hand for function implemented in a compiled language. Unless the term is referring literally to a C function example code, you can assume that it should also work with another compiled language.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="meta_information_about_types"
>meta information about types</a></h2>

<p>You can get the size of a type using the <a href="https://metacpan.org/pod/FFI%3A%3APlatypus%23sizeof" class="podlinkpod"
>FFI::Platypus#sizeof</a> method.</p>

<pre class="sh_perl"> my $intsize = $ffi-&#62;sizeof(&#39;int&#39;);           # usually 4
 my $intarraysize = $ffi-&#62;sizeof(&#39;int[64]&#39;);  # usually 256</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="converting_types"
>converting types</a></h2>

<p>Sometimes it is necessary to convert types. In particular various pointer types often need to be converted for consumption in Perl. For this purpose the <a href="https://metacpan.org/pod/FFI%3A%3APlatypus%23cast" class="podlinkpod"
>FFI::Platypus#cast</a> method is provided. It needs to be used with care though, because not all type combinations are supported. Here are some useful ones:</p>

<pre class="sh_perl"> my $address = $ffi-&#62;cast(&#39;string&#39; =&#62; &#39;opaque&#39;, $string);</pre>

<p>This converts a Perl string to a pointer address that can be used by functions that take an <code>opaque</code> type. Be carefully though that the Perl string is not resized or free&#39;d while in use from C code.</p>

<pre class="sh_perl"> my $string  = $ffi-&#62;cast(&#39;opaque&#39; =&#62; &#39;string&#39;, $pointer);</pre>

<p>This does the opposite, converting a null terminated string (the type of strings used by C) into a Perl string. In this case the string is copied, so the other language is free to deallocate or otherwise manipulate the string after the conversion without adversely affecting the Perl.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="aliases"
>aliases</a></h2>

<p>Some times using alternate names is useful for documenting the purpose of an argument or return type. For this &#34;aliases&#34; can be helpful. The second argument to the <a href="https://metacpan.org/pod/FFI%3A%3APlatypus%23type" class="podlinkpod"
>FFI::Platypus#type</a> method can be used to define a type alias that can later be used by function declaration and attachment.</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;type(&#39;int&#39;    =&#62; &#39;myint&#39;);
 $ffi-&#62;type(&#39;string&#39; =&#62; &#39;mystring&#39;);
 my $f = $ffi-&#62;function( puts =&#62; [&#39;mystring&#39;] =&#62; &#39;myint&#39; );
 $ffi-&#62;attach( puts =&#62; [&#39;mystring&#39;] =&#62; &#39;myint&#39; );</pre>

<p>Aliases are contained without the <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> object, so feel free to define your own crazy types without stepping on the toes of other CPAN developers using Platypus.</p>

<p>One useful application of an alias is when you know types are different on two different platforms:</p>

<pre class="sh_perl"> if($^O eq &#39;MSWin32&#39;)
 {
   $type-&#62;type(&#39;sint16&#39; =&#62; &#39;foo_t&#39;);
 } elsif($^O eq &#39;linux&#39;)
 {
   $type-&#62;type(&#39;sint32&#39; =&#62; &#39;foo_t&#39;);
 }
 
 # function foo takes 16 bit signed integer on Windows
 # and a 32 bit signed integer on Linux.
 $ffi-&#62;attach( foo =&#62; [ &#39;foo_t&#39; ] =&#62; &#39;void&#39; );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TYPE_CATEGORIES"
>TYPE CATEGORIES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Native_types"
>Native types</a></h2>

<p>So called native types are the types that the CPU understands that can be passed on the argument stack or returned by a function. It does not include more complicated types like arrays or structs, which can be passed via pointers (see the opaque type below). Generally native types include void, integers, floats and pointers.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="the_void_type"
>the void type</a></h3>

<p>This can be used as a return value to indicate a function does not return a value (or if you want the return value to be ignored).</p>

<pre class="sh_perl"> $ffi-&#62;type( foo =&#62; [] =&#62; &#39;void&#39; );</pre>

<p>Newer versions of Platypus also allow you to omit the return type and <code>void</code> is assumed.</p>

<pre class="sh_perl"> $ffi-&#62;type( foo =&#62; [] );</pre>

<p>It doesn&#39;t really make sense to use <code>void</code> in any other context. However, because of historical reasons involving older versions of Perl.</p>

<p>It doesn&#39;t really make sense for <code>void</code> to be passed in as an argument. However, because C functions that take no arguments frequently are specified as taking <code>void</code> as this was required by older C compilers, as a special case you can specify a function&#39;s arguments as taking a single <code>void</code> to mean it takes no arguments.</p>

<pre class="sh_perl"> # C: void foo(void);
 $ffi-&#62;type( foo =&#62; [&#39;void&#39;] );
 # same (but probably better)
 $ffi-&#62;type( foo =&#62; [] );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="integer_types"
>integer types</a></h3>

<p>The following native integer types are always available (parentheticals indicates the usual corresponding C type):</p>

<dl>
<dt><a name="sint8"
>sint8</a></dt>

<dd>
<p>Signed 8 bit byte (<code>signed char</code>, <code>int8_t</code>).</p>

<dt><a name="uint8"
>uint8</a></dt>

<dd>
<p>Unsigned 8 bit byte (<code>unsigned char</code>, <code>uint8_t</code>).</p>

<dt><a name="sint16"
>sint16</a></dt>

<dd>
<p>Signed 16 bit integer (<code>short</code>, <code>int16_t</code>)</p>

<dt><a name="uint16"
>uint16</a></dt>

<dd>
<p>Unsigned 16 bit integer (<code>unsigned short</code>, <code>uint16_t</code>)</p>

<dt><a name="sint32"
>sint32</a></dt>

<dd>
<p>Signed 32 bit integer (<code>int</code>, <code>int32_t</code>)</p>

<dt><a name="uint32"
>uint32</a></dt>

<dd>
<p>Unsigned 32 bit integer (<code>unsigned int</code>, <code>uint32_t</code>)</p>

<dt><a name="sint64"
>sint64</a></dt>

<dd>
<p>Signed 64 bit integer (<code>long long</code>, <code>int64_t</code>)</p>

<dt><a name="uint64"
>uint64</a></dt>

<dd>
<p>Unsigned 64 bit integer (<code>unsigned long long</code>, <code>uint64_t</code>)</p>
</dd>
</dl>

<p>You may also use <code>uchar</code>, <code>ushort</code>, <code>uint</code> and <code>ulong</code> as short names for <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code> and <code>unsigned long</code>.</p>

<p>These integer types are also available, but there actual size and sign may depend on the platform.</p>

<dl>
<dt><a name="char"
>char</a></dt>

<dd>
<p>Somewhat confusingly, <code>char</code> is an integer type! This is really an alias for either <code>sint8_t</code> or <code>uint8_t</code> depending on your platform. If you want to pass a character (not integer) in to a C function that takes a character you want to use the perl <a href="https://metacpan.org/pod/perlfunc#ord" class="podlinkpod"
>ord</a> function. Here is an example that uses the standard libc <code>isalpha</code>, <code>isdigit</code> type functions:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(undef);
 $ffi-&#62;type(&#39;int&#39; =&#62; &#39;character&#39;);
 
 my @list = qw(
   alnum alpha ascii blank cntrl digit lower print punct
   space upper xdigit
 );
 
 $ffi-&#62;attach(&#34;is$_&#34; =&#62; [&#39;character&#39;] =&#62; &#39;int&#39;) for @list;
 
 my $char = shift(@ARGV) || &#39;a&#39;;
 
 no strict &#39;refs&#39;;
 printf &#34;&#39;%s&#39; is %s %s\n&#34;, $char, $_, &#38;{&#39;is&#39;.$_}(ord $char) for @list;</pre>

<dt><a name="size_t"
>size_t</a></dt>

<dd>
<p>This is usually an <code>unsigned long</code>, but it is up to the compiler to decide. The <code>malloc</code> function is defined in terms of <code>size_t</code>:</p>

<pre class="sh_perl"> $ffi-&#62;attach( malloc =&#62; [&#39;size_t&#39;] =&#62; &#39;opaque&#39;;</pre>

<p>(Note that you can get <code>malloc</code> from <a href="/pod/FFI/Platypus/Memory.html" class="podlinkpod"
>FFI::Platypus::Memory</a>).</p>

<dt><a name="long,_unsigned_long"
>long, unsigned long</a></dt>

<dd>
<p>On 64 bit systems, this is usually a 64 bit integer. On 32 bit systems this is frequently a 32 bit integer (and <code>long long</code> or <code>unsigned long long</code> are for 64 bit).</p>
</dd>
</dl>

<p>There are a number of other types that may or may not be available if they are detected when <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> is installed. This includes things like <code>wchar_t</code>, <code>off_t</code>, <code>wint_t</code>. You can use this script to list all the integer types that <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> knows about, plus how they are implemented.</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 
 foreach my $type_name (sort $ffi-&#62;types)
 {
   my $meta = $ffi-&#62;type_meta($type_name);
   next unless defined $meta-&#62;{element_type} &#38;&#38; $meta-&#62;{element_type} eq &#39;int&#39;;
   printf &#34;%20s %s\n&#34;, $type_name, $meta-&#62;{ffi_type};
 }</pre>

<p>If you need a common system type that is not provided, please open a ticket in the Platypus project&#39;s GitHub issue tracker. Be sure to include the usual header file the type can be found in.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Enum_types"
>Enum types</a></h3>

<p>C provides enumerated types, which are typically implemented as integer types.</p>

<pre class="sh_perl"> enum {
   BAR = 1,
   BAZ = 2
 } foo_t;
 
 void f(enum foo_t foo);</pre>

<p>Platypus provides <code>enum</code> and <code>senum</code> types for the integer types used to represent enum and signed enum types respectively.</p>

<pre class="sh_perl"> use constant BAR =&#62; 1;
 use constant BAZ =&#62; 2;
 $ffi-&#62;attach( f =&#62; [ &#39;enum&#39; ] =&#62; &#39;void&#39; );
 f(BAR);
 f(BAZ);</pre>

<p>When do you use <code>senum</code>? Anytime the enum has negative values:</p>

<pre class="sh_perl"> enum {
   BAR = -1;
   BAZ = 2;
 } foo_t;
 
 void f(enum foo_t foo);</pre>

<p>Perl:</p>

<pre class="sh_perl"> use constant BAR =&#62; -1;
 use constant BAZ =&#62; 2;
 $ffi-&#62;attach( f =&#62; [ &#39;senum&#39; ] =&#62; &#39;void&#39; );
 f(BAR);
 f(BAZ);</pre>

<p>Dealing with enumerated values with FFI can be tricky because these are usually defined in C header files and cannot be found in dynamic libraries. For trivial usage you can do as illustrated above, simply define your own Perl constants. For more complicated usage, or where the values might vary from platform to platform you may want to consider the new Platypus bundle interface to define Perl constants (essentially the same as an enumerated value) from C space. This is more reliable, but does require a compiler at install time. See <a href="/pod/FFI/Platypus/Constant.html" class="podlinkpod"
>FFI::Platypus::Constant</a> for details.</p>

<p>The main FAQ (<a href="/pod/FFI/Platypus.html#FAQ" class="podlinkpod"
>&#34;FAQ&#34; in FFI::Platypus</a>) also has a discussion on dealing with constants and enumerated types.</p>

<p>There is also a type plugin (<a href="/pod/FFI/Platypus/Type/Enum.html" class="podlinkpod"
>FFI::Platypus::Type::Enum</a>) that can be helpful in writing interfaces that use enums.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Boolean_types"
>Boolean types</a></h3>

<p>At install time Platypus attempts to detect the correct type for <code>bool</code> for your platform, and you can use that. <code>bool</code> is really an integer type, but the type used varies from platform to platform.</p>

<p>C header:</p>

<pre class="sh_perl"> #include &#60;stdbool.h&#62;
 bool foo();</pre>

<p>Platypus</p>

<pre class="sh_perl"> $ffi-&#62;attach( foo =&#62; [] =&#62; &#39;bool&#39; );</pre>

<p>If you get an exception when trying to use this type it means you either have a very old version of Platypus, or for some reason it was unable to detect the correct type at install time. Please open a ticket if that is the case.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="floating_point_types"
>floating point types</a></h3>

<p>The following native floating point types are always available (parentheticals indicates the usual corresponding C type):</p>

<dl>
<dt><a name="float"
>float</a></dt>

<dd>
<p>Single precision floating point (<i>float</i>)</p>

<dt><a name="double"
>double</a></dt>

<dd>
<p>Double precision floating point (<i>double</i>)</p>

<dt><a name="longdouble"
>longdouble</a></dt>

<dd>
<p>Floating point that may be larger than <code>double</code> (<i>longdouble</i>). This type is only available if supported by the C compiler used to build <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a>. There may be a performance penalty for using this type, even if your Perl uses long doubles internally for its number value (NV) type, because of the way <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> interacts with <code>libffi</code>.</p>

<p>As an argument type either regular number values (NV) or instances of <a href="https://metacpan.org/pod/Math%3A%3ALongDouble" class="podlinkpod"
>Math::LongDouble</a> are accepted. When used as a return type, <a href="https://metacpan.org/pod/Math%3A%3ALongDouble" class="podlinkpod"
>Math::LongDouble</a> will be used, if you have that module installed. Otherwise the return type will be downgraded to whatever your Perl&#39;s number value (NV) is.</p>

<dt><a name="complex_float"
>complex_float</a></dt>

<dd>
<p>Complex single precision floating point (<i>float complex</i>)</p>

<dt><a name="complex_double"
>complex_double</a></dt>

<dd>
<p>Complex double precision floating point (<i>double complex</i>)</p>

<p><code>complex_float</code> and <code>complex_double</code> are only available if supported by your C compiler and by libffi. Complex numbers are only supported in very recent versions of libffi, and as of this writing the latest production version doesn&#39;t work on x86_64. It does seem to work with the latest production version of libffi on 32 bit Intel (x86), and with the latest libffi version in git on x86_64.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="opaque_pointers"
>opaque pointers</a></h3>

<p>Opaque pointers are simply a pointer to a region of memory that you do not manage, and do not know or care about its structure. It is like a <code>void *</code> in C. These types are represented in Perl space as integers and get converted to and from pointers by <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a>. You may use <code>pointer</code> as an alias for <code>opaque</code>, although this is discouraged. (The Platypus documentation uses the convention of using &#34;pointer&#34; to refer to pointers to known types (see below) and &#34;opaque&#34; as short hand for opaque pointer).</p>

<p>As an example, libarchive defines <code>struct archive</code> type in its header files, but does not define its content. Internally it is defined as a <code>struct</code> type, but the caller does not see this. It is therefore opaque to its caller. There are <code>archive_read_new</code> and <code>archive_write_new</code> functions to create a new instance of this opaque object and <code>archive_read_free</code> and <code>archive_write_free</code> to destroy this objects when you are done.</p>

<p>C header:</p>

<pre class="sh_perl"> struct archive;
 struct archive *archive_read_new(void);
 struct archive *archive_write_new(void);
 int archive_free(struct archive *);
 int archive_write_free(struct archive *);</pre>

<p>Perl code:</p>

<pre class="sh_perl"> $lib-&#62;find_lib( lib =&#62; &#39;archive&#39; );
 $ffi-&#62;attach(archive_read_new   =&#62; []         =&#62; &#39;opaque&#39;);
 $ffi-&#62;attach(archive_write_new  =&#62; []         =&#62; &#39;opaque&#39;);
 $ffi-&#62;attach(archive_read_free  =&#62; [&#39;opaque&#39;] =&#62; &#39;int&#39;);
 $ffi-&#62;attach(archive_write_free =&#62; [&#39;opaque&#39;] =&#62; &#39;int&#39;);</pre>

<p>It is often useful to alias an <code>opaque</code> type like this so that you know what the object represents:</p>

<pre class="sh_perl"> $lib-&#62;find_lib( lib =&#62; &#39;archive&#39; );
 $ffi-&#62;type(&#39;opaque&#39; =&#62; &#39;archive&#39;);
 $ffi-&#62;attach(archive_read_new   =&#62; [] =&#62; &#39;archive&#39;);
 $ffi-&#62;attach(archive_read_free  =&#62; [&#39;archive&#39;] =&#62; &#39;int&#39;);
 ...</pre>

<p>As a special case, when you pass <code>undef</code> into a function that takes an opaque type it will be translated into <code>NULL</code> for C. When a C function returns a NULL pointer, it will be translated back to <code>undef</code>.</p>

<p>For functions that take a pointer to a void pointer (that is a <code>void **</code>), you can use a pointer to an opaque type. Consider the C code:</p>

<pre class="sh_perl"> struct archive_entry;
 int archive_read_next_header(struct archive *, struvct archive_entry **);</pre>

<p>Once again the internals of <code>archive_entry</code> are not provided. Perl code:</p>

<pre class="sh_perl"> $ffi-&#62;type(&#39;opaque&#39; =&#62; &#39;archive_entry&#39;);
 $ffi-&#62;attach(archive_read_next_header =&#62; [ &#39;archive&#39;, &#39;archive_entry*&#39; ] =&#62; &#39;int&#39;);</pre>

<p>Now we can call this function</p>

<pre class="sh_perl"> my $archive = archive_read_new();
 ...  # additional prep for $active is required
 while(1) {
   my $entry;
   archive_read_next_header($archive, \$entry);
   last unless defined $entry;
   # can now use $entry for other archive_entry_ methods.
 }</pre>

<p>The way <code>archive_read_next_header</code> works, it will return a pointer to the next <code>archive_entry</code> object until it gets to the end, when it will return a pointer to <code>NULL</code> which will be represented in Perl by a <code>undef</code>.</p>

<p>There are a number of useful utility functions for dealing with opaque types in the <a href="/pod/FFI/Platypus/Memory.html" class="podlinkpod"
>FFI::Platypus::Memory</a> module.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Objects"
>Objects</a></h2>

<p>Object types are thin wrappers around two native types: integer and <code>opaque</code> types. They are just blessed references around either of those two types so that methods can be defined on them, but when they get passed to a Platypus xsub they are converted into the native integer or <code>opaque</code> types. This type is most useful when a API provides an OO style interface with an integer or <code>opaque</code> value acting as an instance of a class. There are two detailed examples in the main Platypus documentation using libarchive and unix open:</p>

<dl>
<dt><a name="&#34;libarchive&#34;_in_FFI::Platypus"
><a href="/pod/FFI/Platypus.html#libarchive" class="podlinkpod"
>&#34;libarchive&#34; in FFI::Platypus</a></a></dt>

<dd>
<dt><a name="&#34;unix_open&#34;_in_FFI::Platypus"
><a href="/pod/FFI/Platypus.html#unix_open" class="podlinkpod"
>&#34;unix open&#34; in FFI::Platypus</a></a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Strings"
>Strings</a></h2>

<pre class="sh_perl"> # used when you need a char * or const char *
 $ffi-&#62;attach( puts =&#62; [ &#39;string&#39; ] =&#62; &#39;int&#39; );</pre>

<p>The <code>string</code> type is a series of bytes that usually represent a series of characters. They will be NULL terminated for C and passed in as a pointer. This will typically work for APIs that take ASCII or UTF-8 strings which are common in Unix environments.</p>

<p>(Note if you need to handle the native &#34;wide&#34; string for example if you need to talk UTF-16 on Windows see <a href="/pod/FFI/Platypus/Type/WideString.html" class="podlinkpod"
>FFI::Platypus::Type::WideString</a>).</p>

<p>(Note if you need to pass in a fixed length string by value (not as a pointer) then you can do so using <a href="/pod/FFI/Platypus/Record.html" class="podlinkpod"
>FFI::Platypus::Record</a>).</p>

<p>(Note that languages like <a href="/pod/FFI/Platypus/Lang/Go.html" class="podlinkpod"
>Go</a> and <a href="/pod/FFI/Platypus/Lang/Rust.html" class="podlinkpod"
>Rust</a> do not use NULL terminated strings and need their own string types; see the appropriate language plugins for details)</p>

<pre class="sh_perl"> # can also be used when you need a void * or const void *
 $ffi-&#62;attach( write =&#62; [&#39;int&#39;, &#39;string&#39;, &#39;size_t&#39; ] =&#62; &#39;ssizet&#39; );</pre>

<p>The <code>string</code> type can also be used to pass in the start of a buffer of arbitrary bytes stored in a Perl scalar. Because a <code>string</code> is passed just as a pointer you will typically need to also pass the length of the buffer as a separate argument. This is necessary because buffers could potentially have a NULL in them.</p>

<p>The pointer passed into C (or other language) is to the content of the actual scalar, which means it can modify the content of a scalar.</p>

<p><b>NOTE</b>: When used as a return type, the string is <i>copied</i> into a new scalar rather than using the original address. This is due to the ownership model of scalars in Perl, but it is also most of the time what you want.</p>

<p>This can be problematic when a function returns a string that the callee is expected to free. Consider the functions:</p>

<pre class="sh_perl"> char *
 get_string()
 {
   char *buffer;
   buffer = malloc(20);
   strcpy(buffer, &#34;Perl&#34;);
 }
 
 void
 free_string(char *buffer)
 {
   free(buffer);
 }</pre>

<p>This API returns a string that you are expected to free when you are done with it. (At least they have provided an API for freeing the string instead of expecting you to call libc free)! A simple binding to get the string would be:</p>

<pre class="sh_perl"> $ffi-&#62;attach( get_string =&#62; [] =&#62; &#39;string&#39; );  # memory leak
 my $str = get_string();</pre>

<p>Which will work to a point, but the memory allocated by get_string will leak. Instead you need to get the opaque pointer, cast it to a string and then free it.</p>

<pre class="sh_perl"> $ffi-&#62;attach( get_string =&#62; [] =&#62; &#39;opaque&#39; );
 $ffi-&#62;attach( free_string =&#62; [&#39;opaque&#39;] =&#62; &#39;void&#39; );
 my $ptr = get_string();
 my $str = $ffi-&#62;cast( &#39;opaque&#39; =&#62; &#39;string&#39;, $ptr );  # copies the string
 free_string($ptr);</pre>

<p>If you are doing this sort of thing a lot, it can be worth adding a custom type:</p>

<pre class="sh_perl"> $ffi-&#62;attach( free_string =&#62; [&#39;opaque&#39;] =&#62; &#39;void&#39; );
 $ffi-&#62;custom_type( &#39;my_string&#39; =&#62; {
   native_type =&#62; &#39;opaque&#39;,
   native_to_perl =&#62; sub {
     my($ptr) = @_;
     my $str = $ffi-&#62;cast( &#39;opaque&#39; =&#62; &#39;string&#39;, $ptr ); # copies the string
     free_string($ptr);
     $str;
   }
 });
 
 $ffi-&#62;attach( get_string =&#62; [] =&#62; &#39;my_string&#39; );
 my $str = get_string();</pre>

<p>Since version 0.62, pointers and arrays to strings are supported as a first class type. Prior to that <a href="/pod/FFI/Platypus/Type/StringArray.html" class="podlinkpod"
>FFI::Platypus::Type::StringArray</a> and <a href="/pod/FFI/Platypus/Type/StringPointer.html" class="podlinkpod"
>FFI::Platypus::Type::StringPointer</a> could be used, though their use in new code is discouraged.</p>

<pre class="sh_perl"> $ffi-&#62;attach( foo =&#62; [&#39;string[]&#39;] =&#62; &#39;void&#39; );
 foo( [ &#39;array&#39;, &#39;of&#39;, &#39;strings&#39; ] );
 
 $ffi-&#62;attach( bar =&#62; [&#39;string*&#39;] =&#62; &#39;void&#39; );
 my $string = &#39;baz&#39;;
 bar( \$string );  # $string may be modified.</pre>

<p>Strings are not allowed as return types from closure. This, again is due to the ownership model of scalars in Perl. (There is no way for Perl to know when calling language is done with the memory allocated to the string). Consider the API:</p>

<pre class="sh_perl"> typedef const char *(*get_message_t)(void);
 
 void
 print_message(get_message_t get_message)
 {
   const char *str;
   str = get_message();
   printf(&#34;message = %s\n&#34;, str);
 }</pre>

<p>It feels like this should be able to work:</p>

<pre class="sh_perl"> $ffi-&#62;type(&#39;()-&#62;string&#39; =&#62; &#39;get_message_t&#39;); # not ok
 $ffi-&#62;attach( print_message =&#62; [&#39;get_message_t&#39;] =&#62; &#39;void&#39; );
 my $get_message = $ffi-&#62;closure(sub {
   return &#34;my message&#34;;
 });
 print_message($get_message);</pre>

<p>If the type declaration for <code>get_message_t</code> were legal, then this script would likely segfault or in the very least corrupt memory. The problem is that once <code>&#34;my message&#34;</code> is returned from the closure Perl doesn&#39;t have a reference to it anymore and will free it. To do this safely, you have to keep a reference to the scalar around and return an opaque pointer to the string using a cast.</p>

<pre class="sh_perl"> $ffi-&#62;type(&#39;()-&#62;opaque&#39; =&#62; &#39;get_message_t&#39;);
 $ffi-&#62;attach( print_message =&#62; [&#39;get_message_t&#39;] =&#62; &#39;void&#39; );
 my $get_message =&#62; $ffi-&#62;closure(sub {
   our $message = &#34;my message&#34;;  # needs to be our so that it doesn&#39;t
                                 # get free&#39;d
   my $ptr = $ffi-&#62;cast(&#39;string&#39; =&#62; &#39;opaque&#39;, $message);
   return $ptr;
 });
 print_message($get_message);</pre>

<p>Another type of string that you may run into with some APIs is the so called &#34;wide&#34; string. In your C code if you see <code>wchar_t*</code> or <code>const wchar_t*</code> or if in Win32 API code you see <code>LPWSTR</code> or <code>LPCWSTR</code>. Most commonly you will see these types when working with the Win32 API, but you may see them in Unix as well. These types are intended for dealing with Unicode, but they do not use the same UTF-8 format used by Perl internally, so they need to be converted. You can do this manually by allocating the memory and using the <a href="https://metacpan.org/pod/Encode" class="podlinkpod"
>Encode</a> module, but the easier way is to use either <a href="/pod/FFI/Platypus/Type/WideString.html" class="podlinkpod"
>FFI::Platypus::Type::WideString</a> or <a href="/pod/FFI/Platypus/Lang/Win32.html" class="podlinkpod"
>FFI::Platypus::Lang::Win32</a>, which handle the memory allocation and conversion for you.</p>

<p>String types can be defined to have a fixed length using a trailing parenthetical like so <code>string(10)</code>. For arguments this has little practical effect since the strings are passed as pointers anyway, but does impact return values. If a function that returns a <code>string(10)</code> type returns a string that is not NULL terminated, only the first ten bytes will be returned in the result.</p>

<p>Internally fixed length strings are implemented the same as classless record types (that is to say <code>string(10)</code> is identically internally to <code>record(10)*</code>).</p>

<p>For the 1.00 Platypus API, the <code>string(10)</code> type was specified as a pointer (that is <code>string(10)*</code>). This was a mistake, but you can still use the latter as an alias for the correct form in the 2.00 API.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pointers_and_Arrays_of_Strings"
>Pointers and Arrays of Strings</a></h2>

<p>As of the 1.00 Platypus API, you can specify pointers to strings (<code>string*</code>) and arrays of strings (<code>string[10]</code>). Since strings themselves are passed as pointers, this means these types are passed in as pointers to pointers. If the pointer to the string is changed then when the function returns the scalar or array will be updated as well.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pointer_/_References"
>Pointer / References</a></h2>

<p>In C you can pass a pointer to a variable to a function in order accomplish the task of pass by reference. In Perl the same task is accomplished by passing a reference (although you can also modify the argument stack thus Perl supports proper pass by reference as well).</p>

<p>With <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a> you can define a pointer to any native, string or record type. You cannot (at least not yet) define a pointer to a pointer or a pointer to an array or any other type not otherwise supported. When passing in a pointer to something you must make sure to pass in a reference to a scalar, or <code>undef</code> (<code>undef</code> will be translated int <code>NULL</code>).</p>

<p>If the C code makes a change to the value pointed to by the pointer, the scalar will be updated before returning to Perl space. Example, with C code.</p>

<pre class="sh_perl"> /* foo.c */
 void increment_int(int *value)
 {
   if(value != NULL)
     (*value)++;
   else
     fprintf(stderr, &#34;NULL pointer!\n&#34;);
 }
 
 # foo.pl
 use FFI::Platypus 2.00;
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(&#39;libfoo.so&#39;); # change to reflect the dynamic lib
                         # that contains foo.c
 $ffi-&#62;type(&#39;int*&#39; =&#62; &#39;int_p&#39;);
 $ffi-&#62;attach(increment_int =&#62; [&#39;int_p&#39;] =&#62; &#39;void&#39;);
 my $i = 0;
 increment_int(\$i);   # $i == 1
 increment_int(\$i);   # $i == 2
 increment_int(\$i);   # $i == 3
 increment_int(undef); # prints &#34;NULL pointer!\n&#34;</pre>

<p>Older versions of Platypus did not support pointers to strings or records.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Records"
>Records</a></h2>

<p>Records are structured data of a fixed length. In C they are called <code>struct</code>s.</p>

<p>For most C structured data, as long as you do not need to a record by value, <a href="/pod/FFI/C.html" class="podlinkpod"
>FFI::C</a> is the better choice. Briefly, <a href="/pod/FFI/C.html" class="podlinkpod"
>FFI::C</a> supports <code>struct</code>, <code>union</code>, and arrays of <code>struct</code> and <code>unions</code>. <a href="/pod/FFI/C.html" class="podlinkpod"
>FFI::C</a> does not support passing by value. The reminder of this section will discuss only the <code>record</code> type.</p>

<p>To declare a record type, use <code>record</code>:</p>

<pre class="sh_perl"> $ffi-&#62;type( &#39;record (42)&#39; =&#62; &#39;my_record_of_size_42_bytes&#39; );</pre>

<p>The easiest way to mange records with Platypus is by using <a href="/pod/FFI/Platypus/Record.html" class="podlinkpod"
>FFI::Platypus::Record</a> to define a record layout for a record class. Here is a brief example:</p>

<pre class="sh_perl"> package Unix::TimeStruct;
 
 use FFI::Platypus 2.00;
 use FFI::Platypus::Record;
 
 record_layout_1(qw(
     int    tm_sec
     int    tm_min
     int    tm_hour
     int    tm_mday
     int    tm_mon
     int    tm_year
     int    tm_wday
     int    tm_yday
     int    tm_isdst
     long   tm_gmtoff
     string tm_zone
 ));
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(undef);
 # define a record class Unix::TimeStruct and alias it to &#34;tm&#34;
 $ffi-&#62;type(&#34;record(Unix::TimeStruct)*&#34; =&#62; &#39;tm&#39;);
 
 # attach the C localtime function as a constructor
 $ffi-&#62;attach( localtime =&#62; [&#39;time_t*&#39;] =&#62; &#39;tm&#39;, sub {
   my($inner, $class, $time) = @_;
   $time = time unless defined $time;
   $inner-&#62;(\$time);
 });
 
 package main;
 
 # now we can actually use our Unix::TimeStruct class
 my $time = Unix::TimeStruct-&#62;localtime;
 printf &#34;time is %d:%d:%d %s\n&#34;,
   $time-&#62;tm_hour,
   $time-&#62;tm_min,
   $time-&#62;tm_sec,
   $time-&#62;tm_zone;</pre>

<p>For more detailed usage, see <a href="/pod/FFI/Platypus/Record.html" class="podlinkpod"
>FFI::Platypus::Record</a>.</p>

<p>Platypus does not manage the structure of a record (that is up to you), it just keeps track of their size and makes sure that they are copied correctly when used as a return type. A record in Perl is just a string of bytes stored as a scalar. In addition to defining a record layout for a record class, there are a number of tools you can use manipulate records in Perl, two notable examples are <a href="https://metacpan.org/pod/perlpacktut" class="podlinkpod"
>pack and unpack</a> and <a href="https://metacpan.org/pod/Convert%3A%3ABinary%3A%3AC" class="podlinkpod"
>Convert::Binary::C</a>.</p>

<p>Here is an example with commentary that uses <a href="https://metacpan.org/pod/Convert%3A%3ABinary%3A%3AC" class="podlinkpod"
>Convert::Binary::C</a> to extract the component time values from the C <code>localtime</code> function, and then smushes them back together to get the original <code>time_t</code> (an integer).</p>

<pre class="sh_perl"> use Convert::Binary::C;
 use FFI::Platypus 2.00;
 use Data::Dumper qw( Dumper );
 
 my $c = Convert::Binary::C-&#62;new;
 
 # Alignment of zero (0) means use
 # the alignment of your CPU
 $c-&#62;configure( Alignment =&#62; 0 );
 
 # parse the tm record structure so
 # that Convert::Binary::C knows
 # what to spit out and suck in
 $c-&#62;parse(&#60;&#60;ENDC);
 struct tm {
   int tm_sec;
   int tm_min;
   int tm_hour;
   int tm_mday;
   int tm_mon;
   int tm_year;
   int tm_wday;
   int tm_yday;
   int tm_isdst;
   long int tm_gmtoff;
   const char *tm_zone;
 };
 ENDC
 
 # get the size of tm so that we can give it
 # to Platypus
 my $tm_size = $c-&#62;sizeof(&#34;tm&#34;);
 
 # create the Platypus instance and create the appropriate
 # types and functions
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(undef);
 $ffi-&#62;type(&#34;record($tm_size)*&#34; =&#62; &#39;tm&#39;);
 $ffi-&#62;attach( [ localtime =&#62; &#39;my_localtime&#39; ] =&#62; [&#39;time_t*&#39;] =&#62; &#39;tm&#39;     );
 $ffi-&#62;attach( [ time      =&#62; &#39;my_time&#39;      ] =&#62; [&#39;tm&#39;]      =&#62; &#39;time_t&#39; );
 
 # ===============================================
 # get the tm struct from the C localtime function
 # note that we pass in a reference to the value that time
 # returns because localtime takes a pointer to time_t
 # for some reason.
 my $time_hashref = $c-&#62;unpack( tm =&#62; my_localtime(\time) );
 
 # tm_zone comes back from Convert::Binary::C as an opaque,
 # cast it into a string.  We localize it to just this do
 # block so that it will be a pointer when we pass it back
 # to C land below.
 do {
   local $time_hashref-&#62;{tm_zone} = $ffi-&#62;cast(opaque =&#62; string =&#62; $time_hashref-&#62;{tm_zone});
   print Dumper($time_hashref);
 };
 
 # ===============================================
 # convert the tm struct back into an epoch value
 my $time = my_time( $c-&#62;pack( tm =&#62; $time_hashref ) );
 
 print &#34;time      = $time\n&#34;;
 print &#34;perl time = &#34;, time, &#34;\n&#34;;</pre>

<p>You can also link a record type to a class. It will then be accepted when blessed into that class as an argument passed into a C function, and when it is returned from a C function it will be blessed into that class. Basically:</p>

<pre class="sh_perl"> $ffi-&#62;type( &#39;record(My::Class)*&#39; =&#62; &#39;my_class&#39; );
 $ffi-&#62;attach( my_function1 =&#62; [ &#39;my_class&#39; ] =&#62; &#39;void&#39; );
 $ffi-&#62;attach( my_function2 =&#62; [ ] =&#62; &#39;my_class&#39; );</pre>

<p>The only thing that your class MUST provide is either a <code>ffi_record_size</code> or <code>_ffi_record_size</code> class method that returns the size of the record in bytes.</p>

<p>Here is a longer practical example, once again using the tm struct:</p>

<pre class="sh_perl"> package Unix::TimeStruct;
 
 use FFI::Platypus 2.00;
 use FFI::TinyCC;
 use FFI::TinyCC::Inline &#39;tcc_eval&#39;;
 
 # store the source of the tm struct
 # for repeated use later
 my $tm_source = &#60;&#60;ENDTM;
   struct tm {
     int tm_sec;
     int tm_min;
     int tm_hour;
     int tm_mday;
     int tm_mon;
     int tm_year;
     int tm_wday;
     int tm_yday;
     int tm_isdst;
     long int tm_gmtoff;
     const char *tm_zone;
   };
 ENDTM
 
 # calculate the size of the tm struct
 # this time using Tiny CC
 my $tm_size = tcc_eval qq{
   $tm_source
   int main()
   {
     return sizeof(struct tm);
   }
 };
 
 # To use Unix::TimeStruct as a record class, we need to
 # specify a size for the record, a function called
 # either ffi_record_size or _ffi_record_size should
 # return the size in bytes.  This function has to
 # be defined before you try to define it as a type.
 sub _ffi_record_size { $tm_size };
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(undef);
 # define a record class Unix::TimeStruct and alias it
 # to &#34;tm&#34;
 $ffi-&#62;type(&#34;record(Unix::TimeStruct)*&#34; =&#62; &#39;tm&#39;);
 
 # attach the C localtime function as a constructor
 $ffi-&#62;attach( [ localtime =&#62; &#39;_new&#39; ] =&#62; [&#39;time_t*&#39;] =&#62; &#39;tm&#39; );
 
 # the constructor needs to be wrapped in a Perl sub,
 # because localtime is expecting the time_t (if provided)
 # to come in as the first argument, not the second.
 # We could also acomplish something similar using
 # custom types.
 sub new { _new(\($_[1] || time)) }
 
 # for each attribute that we are interested in, create
 # get and set accessors.  We just make accessors for
 # hour, minute and second, but we could make them for
 # all the fields if we needed.
 foreach my $attr (qw( hour min sec ))
 {
   my $tcc = FFI::TinyCC-&#62;new;
   $tcc-&#62;compile_string(qq{
     $tm_source
     int
     get_$attr (struct tm *tm)
     {
       return tm-&#62;tm_$attr;
     }
     void
     set_$attr (struct tm *tm, int value)
     {
       tm-&#62;tm_$attr = value;
     }
   });
   $ffi-&#62;attach( [ $tcc-&#62;get_symbol(&#34;get_$attr&#34;) =&#62; &#34;get_$attr&#34; ] =&#62; [ &#39;tm&#39; ] =&#62; &#39;int&#39; );
   $ffi-&#62;attach( [ $tcc-&#62;get_symbol(&#34;set_$attr&#34;) =&#62; &#34;set_$attr&#34; ] =&#62; [ &#39;tm&#39; ] =&#62; &#39;int&#39; );
 }
 
 package main;
 
 # now we can actually use our Unix::TimeStruct class
 my $time = Unix::TimeStruct-&#62;new;
 printf &#34;time is %d:%d:%d\n&#34;, $time-&#62;get_hour, $time-&#62;get_min, $time-&#62;get_sec;</pre>

<p>Contrast a record type which is stored as a scalar string of bytes in Perl to an opaque pointer which is stored as an integer in Perl. Both are treated as pointers in C functions. The situations when you usually want to use a record are when you know ahead of time what the size of the object that you are working with and probably something about its structure. Because a function that returns a structure copies the structure into a Perl data structure, you want to make sure that it is okay to copy the record objects that you are dealing with if any of your functions will be returning one of them.</p>

<p>Opaque pointers should be used when you do not know the size of the object that you are using, or if the objects are created and free&#39;d through an API interface other than <code>malloc</code> and <code>free</code>.</p>

<p>The examples in this section actually use pointers to records (note the trailing star <code>*</code> in the declarations). Most programming languages allow you to pass or return a record as either pass-by-value or as a pointer (pass-by-reference).</p>

<p>C code:</p>

<pre class="sh_perl"> struct { int a; } foo_t;
 void pass_by_value_example( struct foo_t foo );
 void pass_by_reference_example( struct foo_t *foo );</pre>

<p>Perl code:</p>

<pre class="sh_perl"> {
   package Foo;
   use FFI::Platypus::Record;
   record_layout_1( int =&#62; &#39;a&#39; );
 }
 $ffi-&#62;type( &#39;Record(Foo)&#39; =&#62; &#39;foo_t&#39; );
 $ffi-&#62;attach( pass_by_value_example =&#62; [ &#39;foo_t&#39; ] =&#62; &#39;void&#39; );
 $ffi-&#62;attach( pass_by_reference_example =&#62; [ &#39;foo_t*&#39; ] =&#62; &#39;void&#39; );</pre>

<p>As with strings, functions that return a pointer to a record are actually copied.</p>

<p>C code:</p>

<pre class="sh_perl"> struct foo_t *return_struct_pointer_example();</pre>

<p>Perl code:</p>

<pre class="sh_perl"> $ffi-&#62;attach( return_struct_pointer_example =&#62; [] =&#62; &#39;foo_t*&#39; );
 my $foo = return_struct_pointer_example();
 # $foo is a copy of the record returned by the function.</pre>

<p>As with strings, if the API expects you to free the record it returns (it is misbehaving a little, but lets set that aside), then you can work around this by returning an <code>opaque</code> type, casting to the record, and finally freeing the original pointer.</p>

<pre class="sh_perl"> use FFI::Platypus::Memory qw( free );
 $ffi-&#62;attach( return_struct_pointer_example =&#62; [] =&#62; &#39;opaque&#39; );
 my $foo_ptr = return_struct_pointer_example();
 my $foo = $ffi-&#62;cast( &#39;opaque&#39; =&#62; &#39;foo_t*&#39;, $foo_ptr );
 free $foo_ptr;</pre>

<p>You can pass records into a closure, but care needs to be taken. Records passed into a closure are read-only inside the closure, including <code>string rw</code> members. Although you can pass a &#34;pointer&#34; to a record into a closure, because of limitations of the implementation you actually have a copy, so all records passed into closures are passed by-value.</p>

<p>Note that a record that does not have a class (classless) and is defined instead using a length is internally identical to fixed strings. That is to say <code>string(10)</code> and <code>record(10)*</code> are identical.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Fixed_length_arrays"
>Fixed length arrays</a></h2>

<p>Fixed length arrays of native types and strings are supported by <a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a>. Like pointers, if the values contained in the array are updated by the C function these changes will be reflected when it returns to Perl space. An example of using this is the Unix <code>pipe</code> command which returns a list of two file descriptors as an array.</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(undef);
 $ffi-&#62;attach([pipe=&#62;&#39;mypipe&#39;] =&#62; [&#39;int[2]&#39;] =&#62; &#39;int&#39;);
 
 my @fd = (0,0);
 mypipe(\@fd);
 my($fd1,$fd2) = @fd;
 
 print &#34;$fd1 $fd2\n&#34;;</pre>

<p>Because of the way records are implemented, an array of records does not make sense and is not currently supported.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Variable_length_arrays"
>Variable length arrays</a></h2>

<p>[version 0.22]</p>

<p>Variable length arrays are supported for argument types can also be specified by using the <code>[]</code> notation but by leaving the size empty:</p>

<pre class="sh_perl"> $ffi-&#62;type(&#39;int[]&#39; =&#62; &#39;var_int_array&#39;);</pre>

<p>When used as an argument type it will probe the array reference that you pass in to determine the correct size. Usually you will need to communicate the size of the array to the C code. One way to do this is to pass the length of the array in as an additional argument. For example the C code:</p>

<pre class="sh_perl"> int
 sum(int *array, int size)
 {
   int total, i;
   for (i = 0, total = 0; i &#60; size; i++)
   {
     total += array[i];
   }
   return total;
 }</pre>

<p>Can be called from Perl like this:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(&#39;./var_array.so&#39;);
 
 $ffi-&#62;attach( sum =&#62; [ &#39;int[]&#39;, &#39;int&#39; ] =&#62; &#39;int&#39; );
 
 my @list = (1..100);
 
 print sum(\@list, scalar @list), &#34;\n&#34;;</pre>

<p>Another method might be to have a special value, such as 0 or NULL indicate the termination of the array.</p>

<p>Because of the way records are implemented, an array of records does not make sense and is not currently supported.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Closures"
>Closures</a></h2>

<p>A closure (sometimes called a &#34;callback&#34;, we use the <code>libffi</code> terminology) is a Perl subroutine that can be called from C. In order to be called from C it needs to be passed to a C function. To define the closure type you need to provide a list of argument types and a return type. Currently only native types (integers, floating point values, opaque), strings and records (by-value; you can pass a pointer to a record, but due to limitations of the record implementation this is actually a copy) are supported as closure argument types, and only native types and records (by-value; pointer records and records with string pointers cannot be returned from a closure) are supported as closure return types. Inside the closure any records passed in are read-only.</p>

<p>We plan to add other types, though they can be converted using the Platypus <code>cast</code> or <code>attach_cast</code> methods.</p>

<p>Here is an example, with C code:</p>

<pre class="sh_perl"> /*
  * closure.c - on Linux compile with: gcc closure.c -shared -o closure.so -fPIC
  */
 
 #include &#60;stdio.h&#62;
 
 typedef int (*closure_t)(int);
 closure_t my_closure = NULL;
 
 void set_closure(closure_t value)
 {
   my_closure = value;
 }
 
 int call_closure(int value)
 {
   if(my_closure != NULL)
     return my_closure(value);
   else
     fprintf(stderr, &#34;closure is NULL\n&#34;);
 }</pre>

<p>And the Perl code:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(&#39;./closure.so&#39;);
 $ffi-&#62;type(&#39;(int)-&#62;int&#39; =&#62; &#39;closure_t&#39;);
 
 $ffi-&#62;attach(set_closure =&#62; [&#39;closure_t&#39;] =&#62; &#39;void&#39;);
 $ffi-&#62;attach(call_closure =&#62; [&#39;int&#39;] =&#62; &#39;int&#39;);
 
 my $closure1 = $ffi-&#62;closure(sub { $_[0] * 2 });
 set_closure($closure1);
 print  call_closure(2), &#34;\n&#34;; # prints &#34;4&#34;
 
 my $closure2 = $ffi-&#62;closure(sub { $_[0] * 4 });
 set_closure($closure2);
 print call_closure(2), &#34;\n&#34;; # prints &#34;8&#34;</pre>

<p>If you have a pointer to a function in the form of an <code>opaque</code> type, you can pass this in place of a closure type:</p>

<pre class="sh_perl"> use FFI::Platypus 2.00;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;lib(&#39;./closure.so&#39;);
 $ffi-&#62;type(&#39;(int)-&#62;int&#39; =&#62; &#39;closure_t&#39;);
 
 $ffi-&#62;attach(set_closure =&#62; [&#39;closure_t&#39;] =&#62; &#39;void&#39;);
 $ffi-&#62;attach(call_closure =&#62; [&#39;int&#39;] =&#62; &#39;int&#39;);
 
 my $closure = $ffi-&#62;closure(sub { $_[0] * 6 });
 my $opaque = $ffi-&#62;cast(closure_t =&#62; &#39;opaque&#39;, $closure);
 set_closure($opaque);
 print call_closure(2), &#34;\n&#34;; # prints &#34;12&#34;</pre>

<p>The syntax for specifying a closure type is a list of comma separated types in parentheticals followed by a narrow arrow <code>-&#62;</code>, followed by the return type for the closure. For example a closure that takes a pointer, an integer and a string and returns an integer would look like this:</p>

<pre class="sh_perl"> $ffi-&#62;type(&#39;(opaque, int, string) -&#62; int&#39; =&#62; &#39;my_closure_type&#39;);</pre>

<p>Care needs to be taken with scoping and closures, because of the way Perl and C handle responsibility for allocating memory differently. Perl keeps reference counts and frees objects when nothing is referencing them. In C the code that allocates the memory is considered responsible for explicitly free&#39;ing the memory for objects it has created when they are no longer needed. When you pass a closure into a C function, the C code has a pointer or reference to that object, but it has no way up letting Perl know when it is no longer using it. As a result, if you do not keep a reference to your closure around it will be free&#39;d by Perl and if the C code ever tries to call the closure it will probably SIGSEGV. Thus supposing you have a C function <code>set_closure</code> that takes a Perl closure, this is almost always wrong:</p>

<pre class="sh_perl"> set_closure($ffi-&#62;closure({ $_[0] * 2 }));  # BAD</pre>

<p>In some cases, you may want to create a closure shouldn&#39;t ever be free&#39;d. For example you are passing a closure into a C function that will retain it for the lifetime of your application. You can use the sticky method to keep the closure, without the need to keep a reference of the closure:</p>

<pre class="sh_perl"> {
   my $closure = $ffi-&#62;closure(sub { $_[0] * 2 });
   $closure-&#62;sticky;
   set_closure($closure); # OKAY
 }
 # closure still exists and is accesible from C, but
 # not from Perl land.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Custom_Types"
>Custom Types</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Custom_Types_in_Perl"
>Custom Types in Perl</a></h3>

<p>Platypus custom types are the rough analogue to typemaps in the XS world. They offer a method for converting Perl types into native types that the <code>libffi</code> can understand and pass on to the C code.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Example_1:_Integer_constants"
>Example 1: Integer constants</a></h4>

<p>Say you have a C header file like this:</p>

<pre class="sh_perl"> /* possible foo types: */
 #define FOO_STATIC  1
 #define FOO_DYNAMIC 2
 #define FOO_OTHER   3
 
 typedef int foo_t;
 
 void foo(foo_t foo);
 foo_t get_foo();</pre>

<p>The challenge is here that once the source is processed by the C pre-processor the name/value mappings for these <code>FOO_</code> constants are lost. There is no way to fetch them from the library once it is compiled and linked.</p>

<p>One common way of implementing this would be to create and export constants in your Perl module, like this:</p>

<pre class="sh_perl"> package Foo;
 
 use FFI::Platypus 2.00;
 use Exporter qw( import );
 
 our @EXPORT_OK = qw( FOO_STATIC FOO_DYNAMIC FOO_OTHER foo get_foo );
 
 use constant FOO_STATIC  =&#62; 1;
 use constant FOO_DYNAMIC =&#62; 2;
 use constant FOO_OTHER   =&#62; 3;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;attach(foo     =&#62; [&#39;int&#39;] =&#62; &#39;void&#39;);
 $ffi-&#62;attach(get_foo =&#62; []      =&#62; &#39;int&#39;);</pre>

<p>Then you could use the module thus:</p>

<pre class="sh_perl"> use Foo qw( foo FOO_STATIC );
 foo(FOO_STATIC);</pre>

<p>If you didn&#39;t want to rely on integer constants or exports, you could also define a custom type, and allow strings to be passed into your function, like this:</p>

<pre class="sh_perl"> package Foo;
 
 use FFI::Platypus 2.00;
 
 our @EXPORT_OK = qw( foo get_foo );
 
 my %foo_types = (
   static  =&#62; 1,
   dynamic =&#62; 2,
   other   =&#62; 3,
 );
 my %foo_types_reverse = reverse %foo_types;
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;custom_type(foo_t =&#62; {
   native_type    =&#62; &#39;int&#39;,
   native_to_perl =&#62; sub {
     $foo_types{$_[0]};
   },
   perl_to_native =&#62; sub {
     $foo_types_reverse{$_[0]};
   },
 });
 
 $ffi-&#62;attach(foo     =&#62; [&#39;foo_t&#39;] =&#62; &#39;void&#39;);
 $ffi-&#62;attach(get_foo =&#62; []        =&#62; &#39;foo_t&#39;);</pre>

<p>Now when an argument of type <code>foo_t</code> is called for it will be converted from an appropriate string representation, and any function that returns a <code>foo_t</code> type will return a string instead of the integer representation:</p>

<pre class="sh_perl"> use Foo;
 foo(&#39;static&#39;);</pre>

<p>If the library that you are using has a lot of these constants you can try using <a href="https://metacpan.org/pod/Convert%3A%3ABinary%3A%3AC" class="podlinkpod"
>Convert::Binary::C</a> or another C header parser to obtain the appropriate name/value pairings for the constants that you need.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Example_2:_Blessed_references"
>Example 2: Blessed references</a></h4>

<p>Supposing you have a C library that uses an opaque pointer with a pseudo OO interface, like this:</p>

<pre class="sh_perl"> typedef struct foo_t;
 
 foo_t *foo_new();
 void foo_method(foo_t *, int argument);
 void foo_free(foo_t *);</pre>

<p>One approach to adapting this to Perl would be to create a OO Perl interface like this:</p>

<pre class="sh_perl"> package Foo;
 
 use FFI::Platypus 2.00;
 use FFI::Platypus::API qw( arguments_get_string );
 
 my $ffi = FFI::Platypus-&#62;new( api =&#62; 2 );
 $ffi-&#62;custom_type(foo_t =&#62; {
   native_type    =&#62; &#39;opaque&#39;,
   native_to_perl =&#62; sub {
     my $class = arguments_get_string(0);
     bless \$_[0], $class;
   }
   perl_to_native =&#62; sub { ${$_[0]} },
 });
 
 $ffi-&#62;attach([ foo_new =&#62; &#39;new&#39; ] =&#62; [ &#39;string&#39; ] =&#62; &#39;foo_t&#39; );
 $ffi-&#62;attach([ foo_method =&#62; &#39;method&#39; ] =&#62; [ &#39;foo_t&#39;, &#39;int&#39; ] =&#62; &#39;void&#39;);
 $ffi-&#62;attach([ foo_free =&#62; &#39;DESTROY&#39; ] =&#62; [ &#39;foo_t&#39; ] =&#62; &#39;void&#39;);
 
 my $foo = Foo-&#62;new;</pre>

<p>Here we are blessing a reference to the opaque pointer when we return the custom type for <code>foo_t</code>, and dereferencing that reference before we pass it back in. The function <code>arguments_get_string</code> queries the C arguments to get the class name to make sure the object is blessed into the correct class (for more details on the custom type API see <a href="/pod/FFI/Platypus/API.html" class="podlinkpod"
>FFI::Platypus::API</a>), so you can inherit and extend this class like a normal Perl class. This works because the C &#34;constructor&#34; ignores the class name that we pass in as the first argument. If you have a C &#34;constructor&#34; like this that takes arguments you&#39;d have to write a wrapper for new.</p>

<p>A good example of a C library that uses this pattern, including inheritance is <code>libarchive</code>. Platypus comes with a more extensive example in <code>examples/archive.pl</code> that demonstrates this.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Example_3:_Pointers_with_pack_/_unpack"
>Example 3: Pointers with pack / unpack</a></h4>

<p>TODO</p>

<p>See example <a href="/pod/FFI/Platypus/Type/StringPointer.html" class="podlinkpod"
>FFI::Platypus::Type::StringPointer</a>.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Example_4:_Custom_Type_modules_and_the_Custom_Type_API"
>Example 4: Custom Type modules and the Custom Type API</a></h4>

<p>TODO</p>

<p>See example <a href="/pod/FFI/Platypus/Type/PointerSizeBuffer.html" class="podlinkpod"
>FFI::Platypus::Type::PointerSizeBuffer</a>.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Example_5:_Custom_Type_on_CPAN"
>Example 5: Custom Type on CPAN</a></h4>

<p>You can distribute your own Platypus custom types on CPAN, if you think they may be applicable to others. The default namespace is prefix with <code>FFI::Platypus::Type::</code>, though you can stick it anywhere (under your own namespace may make more sense if the custom type is specific to your application).</p>

<p>A good example and pattern to follow is <a href="/pod/FFI/Platypus/Type/StringArray.html" class="podlinkpod"
>FFI::Platypus::Type::StringArray</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<dl>
<dt><a name="FFI::Platypus"
><a href="/pod/FFI/Platypus.html" class="podlinkpod"
>FFI::Platypus</a></a></dt>

<dd>
<p>Main platypus documentation.</p>

<dt><a name="FFI::Platypus::API"
><a href="/pod/FFI/Platypus/API.html" class="podlinkpod"
>FFI::Platypus::API</a></a></dt>

<dd>
<p>Custom types API.</p>

<dt><a name="FFI::Platypus::Type::StringPointer"
><a href="/pod/FFI/Platypus/Type/StringPointer.html" class="podlinkpod"
>FFI::Platypus::Type::StringPointer</a></a></dt>

<dd>
<p>String pointer type.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Author: Graham Ollis &#60;plicease@cpan.org&#62;</p>

<p>Contributors:</p>

<p>Bakkiaraj Murugesan (bakkiaraj)</p>

<p>Dylan Cali (calid)</p>

<p>pipcet</p>

<p>Zaki Mughal (zmughal)</p>

<p>Fitz Elliott (felliott)</p>

<p>Vickenty Fesunov (vyf)</p>

<p>Gregor Herrmann (gregoa)</p>

<p>Shlomi Fish (shlomif)</p>

<p>Damyan Ivanov</p>

<p>Ilya Pavlov (Ilya33)</p>

<p>Petr P&#237;sa&#345; (ppisar)</p>

<p>Mohammad S Anwar (MANWAR)</p>

<p>H&#229;kon H&#230;gland (hakonhagland, HAKONH)</p>

<p>Meredith (merrilymeredith, MHOWARD)</p>

<p>Diab Jerius (DJERIUS)</p>

<p>Eric Brine (IKEGAMI)</p>

<p>szTheory</p>

<p>Jos&#233; Joaqu&#237;n Atria (JJATRIA)</p>

<p>Pete Houston (openstrike, HOUSTON)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2015-2022 by Graham Ollis.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>


    <div class="nx-footer">
      <p>
        [
            <a href="https://wdlabs.com">wdlabs.com</a> |
            <a href="https://alienfile.org">alienfile.org</a> |
            <a href="https://pl.atypus.org">pl.atypus.org</a> |
            <a href="https://perlwasm.github.io">perlwasm</a> |
            <a href="https://uperl.github.io">uperl</a>
        ]
        Copyright &copy; 2022 Graham Ollis
      </p>
    </div>
  </body>
</html>
